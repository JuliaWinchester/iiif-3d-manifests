"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const { existsSync, readFileSync } = require('fs');
const { glob } = require('glob');
const { basename, dirname, extname, join } = require('path');
const urljoin = require('url-join');
const chalk = require('chalk');
const config = require('./config');
const contentAnnotationBoilerplate = require('./boilerplate/contentannotation');
const yaml = require('js-yaml');
const Utils_1 = require("./Utils");
class Canvas {
    constructor(filePath, url) {
        this.infoYml = {};
        this.filePath = filePath;
        this.url = url;
    }
    create(canvasJson) {
        this.canvasJson = canvasJson;
        this._getMetadata();
        this._applyMetadata();
        Utils_1.Utils.getThumbnail(this.canvasJson, this.url, this.filePath);
        // for each jpg/pdf/mp4/obj in the canvas directory
        // add a contentannotation
        const files = glob.sync(this.filePath + '/*.*', {
            ignore: [
                '**/thumb.*' // ignore thumbs
            ]
        });
        const matchingFiles = [];
        files.forEach((file) => {
            const extName = extname(file);
            // if config.canvasAnnotationTypes has a matching extension
            const matchingExtension = config.canvasAnnotationTypes[extName];
            let directoryName = dirname(file);
            directoryName = directoryName.substr(directoryName.lastIndexOf('/'));
            const fileName = basename(file);
            const id = urljoin(this.url.href, directoryName, fileName);
            if (matchingExtension) {
                const annotationJson = Utils_1.Utils.cloneJson(contentAnnotationBoilerplate);
                annotationJson.id = urljoin(canvasJson.id, 'annotation', matchingFiles.length);
                annotationJson.target = canvasJson.id;
                annotationJson.body.id = id;
                annotationJson.body.type = matchingExtension.type;
                annotationJson.body.format = matchingExtension.format;
                annotationJson.body.label = Utils_1.Utils.getLabel(this.infoYml.label);
                canvasJson.items[0].items.push(annotationJson);
                matchingFiles.push(file);
            }
        });
        if (!matchingFiles.length) {
            console.warn(chalk.yellow('Could not find any files to annotate onto ' + this.filePath));
        }
    }
    _getMetadata() {
        this.infoYml = {};
        // if there's an info.yml
        const ymlPath = join(this.filePath, 'info.yml');
        if (existsSync(ymlPath)) {
            this.infoYml = yaml.safeLoad(readFileSync(ymlPath, 'utf8'));
            console.log(chalk.green('got metadata for: ') + this.filePath);
        }
        else {
            console.log(chalk.green('no metadata found for: ') + this.filePath);
        }
        if (!this.infoYml.label) {
            // default to the directory name
            this.infoYml.label = basename(this.filePath);
        }
    }
    _applyMetadata() {
        this.canvasJson.label = Utils_1.Utils.getLabel(this.infoYml.label); // defaults to directory name
        if (this.infoYml.metadata) {
            this.canvasJson.metadata = Utils_1.Utils.formatMetadata(this.infoYml.metadata);
        }
    }
}
exports.Canvas = Canvas;
